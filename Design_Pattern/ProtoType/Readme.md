# 设计模式———原型模式（克隆模式）

[TOC]

## 引言

在上一章中，向大家介绍的是设计模式中的生成器模式（建造者模式）。先回顾一下，**生成器模式**和工厂模式的区别就在于工厂模式是重在结果，而生成器模式是在于过程，通过用相同的方式，但不同的组合方式，排列方式，生成不同的对象，重在于过程。

在这一章中，我们来学习一个新的设计模式———原型模式（克隆模式），顾名思义，这就是一个通过克隆方式生成对象的一种设计模式，具体怎么克隆，为什么需要克隆模式，下面我们就来一起学习这个新的模式。（这个模式也是我理解了一段时间，主要是不清楚该怎么写，因为这个模式比较于前面两个感觉既简单又抽象）

## 原型模式

### 一、别称

**克隆模式**，**prototype**

### 二、意图

原型模式（克隆模式）也是一种创造型模式，他的特点是可以让你复制已有的对象，但又不需要依赖于这个对象所属的类。通俗的说法，他可以不需要你去了解需要复制对象的所有属性（毕竟你是复制这个对象，是需要知道这个对象的属性的）就可以生成与这个对象一样的复制品。是不是很神奇，但感觉又好像实用性不太高。没关系，我一开始也这样感觉，后面你们就懂了。

### 三、问题

假设我有一个对象，这个对象的属性非常多，而我又希望能创造出更多这样的一个对象，比如我有一个椅子对象，他的长宽高，还有他的材质，是否带扶手，是否带靠背，几个腿等等。。。这一个对象我想要造更多一样的，那我是不是就需要遍历需要复制的椅子的所有属性，保存下来并拷贝到新的对象中去。

没错，这是最简单粗暴的办法，但其中有些小问题，并不是所有的属性都是可以遍历得到的，他有可能是私有属性，那我得到的这些复制体怎么又会和他一样呢？

还有一个问题，我需要复制这把椅子是因为我知道他是一把椅子，但如果我连他是什么都不知道的时候，我又该怎么去复制他呢？这样看是不是很抽象，没错！现在开始我需要强调一点，设计模式就是一种**面向抽象**的编程模式，他**不是针对某一个特定的对象和类而去设计**的，这个用代码解释大家就会清楚一些了。

```c++
#include <iostream>
#include <vector>

// 抽象类接口
class product {
public:
    virtual void build() const = 0;
    virtual ~product() {}
};

// 椅子类，实现接口
class Chair : public product {
private:
    double length;//长
    double width;//宽
    //....
public:
    Chair(double l, double w) : length(l), width(w) {}
    void build() const override {
        std::cout << "Build the chair with length and width : " << length << width << 			std::endl;
    }
};

// 桌子类，实现接口
class Table : public product {
private:
    double width;
    double height;
public:
    Table(double w, double h) : width(w), height(h) {}
    void build() const override {
        std::cout << "Build the chair with width and height : " << width << " and height: " << height << std::endl;
    }
};

// 生产函数，参数接收实现了接口的对象
void producter(const std::vector<product*>& products) {
    for (const auto product : products) {
        product->build();
    }
}

int main() {
    Chair chair(5.0, 6.0);
   	Table table(4.0, 6.0);

    std::vector<product*> products;
    shapes.push_back(&chair);
    shapes.push_back(&table);

    producter(products);

    // 释放内存，避免内存泄漏（因为使用了指针）
    for (auto product : products) {
        delete product;
    }
    return 0;
}
```

如果我作为客户，我只能使用**producter**这个函数去生成这些产品，那我该如何知道他是哪个具体类的，即使我用**decltype**方法去做类型推导，也只能知道他是哪个产品，但参数，我是不知道的，那我又该怎么去复制我想要复制的对象呢？所以！这个时候，你还觉得原型模式不实用吗？下面，就请欢迎我们本文章的主角———**原型模式**。

### 四、解决办法

在我们意识到这些问题的时候，已经有大佬专门为这种情况发明了一种设计模式，就是**原型模式**，又名**克隆模式**。原型模式将克隆的过程委派给了需要被克隆的具体对象，该模式为所有需要被克隆的对象声明了一个名为**clone**的通用接口，他也是通过实现抽象类的纯虚函数来实现的，每一个实例化对象都会带有这个接口，来解决我们刚刚无法解决的问题，这个接口既可以让你克隆想要克隆的对象，又无需与其底层代码耦合，是属于一个既要又要的设计模式。

当我需要克隆的对象的数量到达一个数量级的时候，他甚至可以代替构造函数。并且在设计的时候可以在底层中对他的克隆方式进行修改，也就是说，我先创造一把椅子作为**原型**，然后我需要一模一样的椅子的时候，我不需要对其参数进行更改就可以实现，而当我需要一个高一点的椅子的时候，修改其克隆的参数即可，一句话，方便又快捷。

### 五、应用场景

1. 很明显，在我们需要对一个对象进行重复的生成的时候，就可以使用原型模式。
2. 在设计客户端时，原型模式可以为客户端提供一个统一的接口，客户端就可以克隆所有实现了的对象并且和其实现的具体类解耦合。

### 六、优缺点

#### 优点

- 你可以克隆对象， 而无需与它们所属的具体类相耦合。这一点在上面的例子中非常明显。
- 你可以克隆预生成原型， 避免反复运行初始化代码。其实和上面的优点师出同门。
- 你可以更方便地生成复杂对象。这个优点就是在我设计我的椅子时给他加了很多参数而我在克隆时不需要在遍历这些属性，甚至我可能都遍历不到。

#### 缺点

- 克隆包含循环引用的复杂对象可能会非常麻烦。这个问题解释起来非常的繁琐，我先解释一下什么是循环引用大家就会清楚为什么会克隆循环引用的对象非常麻烦。

  ```c++
  #include <iostream>
  #include <memery>
  
  class ClassA {
  public:
      std::shared_ptr<ClassB> bPtr;
  };
  class ClassB {
  public:
      std::shared_ptr<ClassA> aPtr;
  };
  
  int main() {
      auto a = std::make_shared<ClassA>();
      auto b = std::make_shared<ClassB>();
      a->bPtr = b;
      b->aPtr = a;
      return 0;
  }
  ```

  这就是一个比较简单循环引用，学过智能指针的都知道，这会使他的引用计数永远不会降为0，如果这样的循环引用有3个，或者4个，当然我相信不会有人这样写代码，但我也相信如果有人要写这样的代码，谁又能拦得住呢，这时候用weak_ptr去解决嘛，这里不深入解释。而当我们的克隆模式将这么一个对象给克隆出来了，就会造成内存泄漏等诸多问题，怎么解决？这里我也不懂哈哈哈哈，等我搞懂了后面再写一篇，专门讲一下这个。

  ### 总结

  这篇文章中我们介绍了设计模式中的原型模式，其实这个模式的复杂度不高，用的地方其实也就那几个，在写这篇文章的时候因为中间也出现了些小插曲，所以慢了不少，最主要是在我最初了解这个设计模式的时候我并不知道这个模式的具体应用场景和实现原理上，浪费了不少时间去理解，而在我理解之后我又感觉这个模式挺有意思的，确实也可以减少许多繁琐的耦合度高的工作。原型模式不需要依赖他的具体类的构造已经参数就可以克隆出大量的相同对象，把他理解成cv操作就可以啦，cv就是个好东西，越用越上头的。

  本次内容到此结束，文章主要是分享心得，有不同意见的同学，可以在下面留言，我及时更改，如果这篇文章对你有帮助，可以给个三连谢谢~

